function individualsListOut = Xing(~,individualsListIn)
% crossing the chromosomes
% works on a list of individuals

if ~isa(individualsListIn,'individual')
    error('Xing:InPutMustBeIndividual','The input must be a cell array. Each entry must be a individual object')
end

n = length(individualsListIn);
if n==1,
    error('Xing:WrongNumberElementsInList','X-ing makes only sence if there are at least TWO individuals.')
end

m = 1;  % counter for new generation
for k = 1:n-1
    for l = k+1:n
        % we call now the x-ing method from individual class
         [individualsListOut(m),individualsListOut(m+1)] =...   
             individualsListIn(k).xing(individualsListIn(l)); 
         m = m+2;
    end
end

end

function individualsListOut = XingR(~,individualsListIn)
% crossing the chromosomes
% works on a list of individuals

if ~isa(individualsListIn,'individual')
    error('Xing:InPutMustBeIndividual','The input must be a cell array. Each entry must be a individual object')
end

n = length(individualsListIn);
if n==1,
    error('Xing:WrongNumberElementsInList','X-ing makes only sence if there are at least TWO individuals.')
end

m = 1;  % counter for new generation
for k = 1:n-1
    for l = k+1:n
        % we call now the x-ing method from individual class
         [individualsListOut(m),individualsListOut(m+1)] =...   
             individualsListIn(k).xingR(individualsListIn(l)); 
         m = m+2;
    end
end

end

function batchRe = batchReactor(obj)
% batchReactor(mechanism)
if nargin == 0
    error('individual:batchReactor',...
        'Creating  batchReactor from individual Object failed.')
end

user = getenv('USER');
[success,message,~] = mkdir(['/home/',user],'tempdir') ;
if success < 1 && ~strcmp(messageID,'MATLAB:MKDIR:DirectoryExists')     
        error('ga:evaluate:mkdirFailed',['Making the temporary directory failed with ',...           
        message]);     
end

% checks, what file we have in the reference object
mechFileExtension = obj.mechanism(max(strfind(obj.mechanism,'.'))+1:end);

mechFile = ['/home/',user,'/tempdir/tempMechfile',num2str(randi(999,1,1)),'.',mechFileExtension];
            % first make the mechanism        
           
batchRe = batchReactor();
batchRe.removeSpecies(obj.mechanism,mechFile,obj.speciesNotInclude,...
                obj.names(obj.speciesNotInclude));
end   function createMech(obj,baseMech,mechFile)
% Method for creating a mechanism file from the
% genetic information of individual class
%  Ususage:
% individual.createMech(baseMech,mechFile)
% baseMech should be the same mechanism as in 
% individual.mechanism, but it may differ in the format cti/inp or the file
% location. mechFile ist the name of the traget. It can be a valid path.
% (C) 2012 Uwe PrÃ¼fert for VIRTUHCON

% only to instiate a son of chemistry
reactor = batchReactor(baseMech);
try
    reactor.removeSpecies(baseMech,mechFile,...
                        obj.speciesNotInclude,...
                        obj.names(obj.speciesNotInclude));
catch ME
    throw(ME);
end
endfunction  individualsListOut = evaluate(individualsListIn,refSolObj,objective,varargin)
%individualsListOut = evaluate(individualsListIn,referenceSolutionobject,evaluateFunction[,optional arguments])
global mechanismpath 
user = getenv('USER');

if isempty(mechanismpath)
    mechanismpath = ['/home/',user,'/mechanisms/'];
end


 
[status,result]  = system(['mkdir ',mechanismpath]);
if status~=0
    fprintf(1,['evaluate: A (possible) problem occured when trying mkdir. The message was:\n\t',...
        result,'\n']);    
end
% open the data file



fprintf(1,'^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n');
fprintf(1,'!This is evaluate, it evaluates (sic!) a generation of   species in the GA.!\n');
fprintf(1,'vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n');
% some input checking

if ~isa(individualsListIn,'individual')
    error('evaluate:InPutMustBeIndividual','The input must be a cell array. Each entry must be a individual object')
end


% a hiden folder for all mechanisms

% some definitions


if length(varargin)==1
    cases = 2;
    if ~isa(refSolObj,'referenceSolutionCube')
        error('evaluate:WrongClass','The reference solution object must be from class referenceSolutionCube.')
    end
    if isa(varargin{1},'scenario')
        scen = varargin{1};
        if isempty(scen.temperatures)
            scen = scen.setTemperatures(refSolObj.initialTemperature);
        end
        if isempty(scen.pressures)
            scen = scen.setPressures(refSolObj.initialPressure);
        end
        if isempty(scen.moleFractions)
            scen = scen.addMoleFractions(refSolObj.initialMoleFractions);
        end
    else
        error('evaluate:ArgumentNotSupported','The argument should be a scenario object.')
    end
elseif length(varargin)>1
    error('evaluate:TooManyInputs','Too many input arguments found.')
else
    if ~isa(refSolObj,'chemistry')
        error('evaluate:WrongClass','The reference solution object must be from class chemistry.')
    end
    cases = 1;
end
    

n = length(individualsListIn);


% the main loop over all individuals
for k = 1:n
    
    
    
    % switch the case "one szenario" or "multiszenario" evaluation
    switch cases
        case 1 % single scenario evaluation
            % if the value field is empty,
            % perform the evaluation defines by the function_handle
            if isempty(individualsListIn(k).value)
                % a name for the mechanism and create the mechanism file
                % for this individual
                fprintf(1,'\t\t\t\t------------------\n');
                fprintf(1,'\t\t\t\t! Remove species !\n');
                fprintf(1,'\t\t\t\t------------------\n');
                mechName = [mechanismpath,'mech',num2str(randi(100000000,1)),'.',refSolObj.mechanism(end-2:end)];
                removeSpecies(refSolObj.mechanism,mechName,individualsListIn(k).speciesNotInclude,...
                    individualsListIn(k).names(individualsListIn(k).speciesNotInclude));
                individualsListIn(k).mechanism = mechName;
                % prepare the chemistry object
                sol = chemistry(individualsListIn(k).mechanism);
                sol.initialMoleFractions = refSolObj.initialMoleFractions;
                sol.initialMassFractions = refSolObj.initialMassFractions;
                sol.compLeft = refSolObj.compLeft;
                sol.compRight = refSolObj.compRight;
                sol.mdotLeft = refSolObj.mdotLeft;
                sol.mdotRight = refSolObj.mdotRight;
                sol = sol.setSpace(refSolObj.space);
                sol.initialPressure = refSolObj.initialPressure;
                sol.initialTemperature = refSolObj.initialTemperature; 
                sol.simulationTime = refSolObj.simulationTime;
                % evaluation, solve the reactor and evaluate the objective
                sol = sol.setReactor(refSolObj.reactor);                           
                sol = feval(sol.reactor,sol);  
                
                %%%%%%%%%%%%%%%%%%%
%                 hold on
%                 if strcmp(refSolObj.reactor,'counterFlowFlame')
%                     plot(sol.space,sol.temp,'k');
%                     drawnow
%                 else
%                     plot(sol.times,sol.temp,'k')
%                     drawnow
%                 end
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                
                individualsListIn(k).value = feval(objective,refSolObj,sol);
                [fid,message] = fopen([mechanismpath,'results.txt'],'a');
                if fid <= 2
                    fprintf(['evaluate. Something wrong with fopen. The message was: ',message,'\n'])
                end
                if individualsListIn(k).value~=Inf,
                    fprintf(fid,individualsListIn(k).mechanism);
                    fprintf(fid,'\tnspecies: %4d \tn of living species: %4d  ignition: %6.4e f(T,X) = %6.4e \n',...
                        length(getSpeciesFromMech(mechName)), sol.nLivingSpecies, sol.ignt, individualsListIn(k).value); 
                
                else
                    % eval is infty, we clear the mechfile, and don't write
                    % anything in the results.txt file
                    delete(mechName);
                end
                    fclose('all');
                    sol.clear;
               
            else
                fprintf(1,'Warning: individual has a value, skippig evaluation:\t');
                fprintf(1,[individualsListIn(k).mechanism,'\n']);
                [fid,message] = fopen([mechanismpath,'results.txt'],'a');
                if fid <= 2
                    fprintf(['evaluate. Something wrong with fopen. The message was: ',message,'\n'])
                end
                fprintf(fid,individualsListIn(k).mechanism);
                fprintf(fid,'\t\t\t\t\t');
                fprintf(fid,'f(T,X) = %6.4e',individualsListIn(k).value);
                fprintf(fid,'\n');
                fclose('all');
            end
            
            % some documentation
            
        case 2 % multi scenario evaluation
            mechName = [mechanismpath,'mech',num2str(randi(100000000,1)),'.',refSolObj.mechanism(end-2:end)];
            removeSpecies(refSolObj.valueCube(1,1,1).mechanism,mechName,individualsListIn(k).speciesNotInclude,...
                individualsListIn(k).names(individualsListIn(k).speciesNotInclude));
            % now, the individual get its mechanism
            individualsListIn(k).mechanism = mechName;
            nTemp = length(scen.temperatures);
            nPress= length(scen.pressures);
            nMoleFracs = length(scen.moleFractions);
            individualsListIn(k).value = 0;
            sol = chemistry(individualsListIn(k).mechanism);
            sol.simulationTime = refSolObj.valueCube(1,1,1).simulationTime;
            fprintf(fid,[mechName,': \n']);
            fprintf(fid,[mechName,'\n']);
            livingspecies = 0;
            for l = 1:nTemp
                sol.initialTemperature = scen.temperatures(l);
                for m = 1:nPress
                    sol.initialPressure = scen.pressures(m);
                    for r = 1:nMoleFracs
                        sol.initialMoleFractions = scen.moleFractions{r};
                        sol = feval(sol.reactor,sol);
                        % perform the evaluation defines by the
                        % function_handle evaluation
                        val= feval(objective,refSolObj.valueCube(l,m,r),sol); 
                        individualsListIn(k).value = ...
                            individualsListIn(k).value+val; 
                        fprintf(fid,'   nspecies: %4d nliving species: %4d ignition: %6.4e f(T,X) = %6.4e \n',...
                            [sol.nSpecies  sol.nLivingSpecies sol.ignt val]); 
                        fprintf(fid,'   nspecies: %4d nliving species: %4d ignition: %6.4e f(T,X) = %6.4e \n',...
                            [sol.nSpecies  sol.nLivingSpecies sol.ignt val]); 
                        if sol.nLivingSpecies >livingspecies
                            livingspecies = sol.nLivingSpecies;
                        end
                    end
                end
            end
            
            individualsListIn(k).value = individualsListIn(k).value*1/l/m/r;
            fprintf(fid,'\n\n------------------+++++++++++++++++++------------------\n\n');
            fprintf(fid,'   nspecies: %4d nliving species: %6.4e f(T,X) = %6.4e \n',...
                            [sol.nSpecies  livingspecies  individualsListIn(k).value]);  
            fprintf(fid,'\n\n------------------+++++++++++++++++++------------------\n\n');
            sol.clear;
        otherwise
    end
 
    
end

% creating the output
individualsListOut = individualsListIn;
[fid,message] = fopen([mechanismpath,'results.txt'],'a');
if fid <= 2
    fprintf(['evaluate. Something wrong with fopen. The message was: ',message,'\n'])
end
fprintf(fid,'\n\n------------------ xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ------------------\n\n');
fclose('all');
% local functions
   


end


function individualsListOut = firstGeneration(adam,nOfIndividuals)
%individualsListOut = firstGeneration(individualsListIn,nOfIndividuals)
% Creates the first generation from the "ADAM" individual by mutation and
% crossing.

 
if ~isa(adam,'cell')
    error('Xing:InPutMustBeCell','The input must be a cell array. Each entry must be a individual object')
end
if ~isa(adam{1},'individual')
    error('Xing:InPutMustBeIndividual','The input must be a cell array. Each entry must be a individual object')
end

for k = 1:floor(sqrt(nOfIndividuals))
   individualsListIn{k} = mutation(adam,0.5);  
end
individualsListOut=individualsListIn
end
classdef individual
%individual: class for individuals of a mechanismn polulation
% properties:
%        chromosome: logical
%         reactions: logical
%             fixed: logical
%         mechanism: string
%             value: double
%             names: cell 
%             index: double
% speciesNotInclude: double
% 
% Methods for class individual:
% 
% deleteSpecies   individual      mutationFixedN  xing            
% fix             mutation        removeSpecies   

    
    properties              
        fixed = []; 
        value = inf;     % field for the value of the evaluation
    end
    
    properties (SetAccess = private)
        chromosome = [];   
        reactions = []; % multiplier for reactions, switch on/off      
        index = []; % multiplier for species, switch on/off    
        speciesNotInclude = []; % ~indx to identify removed
                                % species in a fast way
        
    end
    
    % Change properties only by the contructor
    properties (SetAccess = immutable)         
        mechanism = []; % path to mechamism file
        names = [];     % species names       
    end
    
    methods
        function obj = individual(mechfile)
            switch nargin
                case 0
                    % do nothing, empty indvidual object,
                    % only to create (empty) lists etc.
                case 1
                    % constructor method for individual class
                    try
                    obj.names = chemistry.getSpeciesFromMech(mechfile);
                    catch ME
                        throwAsCaller(ME)
                    end
                    isCTI = strcmp(mechfile(strfind(mechfile,'.')+1:end),'cti');
                    if isCTI
                        b = chemistry.indexCtiFile(mechfile);
                        obj.reactions = logical(1:b.nreactions);
                    end
                    obj.chromosome = logical(1:length(obj.names));
                    obj.fixed = ~logical(1:length(obj.names));
                    obj.mechanism = mechfile;                    
                    obj.index = find(obj.chromosome); 
                    obj.speciesNotInclude = find(~obj.chromosome);
                otherwise
            end
            obj.value = inf;
        end
            
        function obj = setMechanism(~,mech)
            switch nargin               
                case 2
                    try
                        obj = individual(mech);
                    catch ME
                        throwAsCaller(ME)
                    end
                otherwise
                    error('individual:setBaseMech','Use setBaseMech setBaseMech(''mechfile'')');
            end            
        end
        function obj = removeSpecies(obj,listOfSpecies)
            % deletes only if it is not a fixed species
            % two possible ways to define the to-remove species:
            for ll = 1:length(obj)
                if isa(listOfSpecies,'numeric')
                    for k = 1:length(listOfSpecies) 
                        if ~obj(ll).fixed(listOfSpecies(k))
                            obj(ll).chromosome(listOfSpecies(k)) = false;
                        end
                    end
                elseif isa(listOfSpecies,'cell')
                    for l = 1:length(obj(ll).names)
                        for k = 1:length(listOfSpecies)                         
                            if ~obj(ll).fixed(l)&&strcmp(obj(ll).names{l},listOfSpecies{k})
                                obj(ll).chromosome(l) = false;
                            end
                        end
                    end
                elseif isa(listOfSpecies,'char')
                    for l = 1:length(obj.names),
                        if ~obj(ll).fixed(l)&&strcmp(obj(ll).names{l},listOfSpecies)
                            obj(ll).chromosome(l) = false;
                        end
                    end
                else
                    %
                end
                obj.index = find(obj.chromosome);
                obj.speciesNotInclude = find(~obj.chromosome);
            end
        end
        
        function obj = deleteSpecies(obj,listOfSpecies)
            % delete action: remove the species also if it is a fixed one
            % two possible ways to define the to-delete species:
            for ll = 1:length(obj)
                if isa(listOfSpecies,'numeric')
                    for k = 1:length(listOfSpecies)  
                        obj(ll).chromosome(listOfSpecies(k)) = false; 
                        obj(ll).fixed(listOfSpecies(k)) = false;                   
                    end
                elseif isa(listOfSpecies,'cell')
                    for l = 1:length(obj(ll).names),
                        for k = 1:length(listOfSpecies)                         
                            if strcmp(obj(ll).names{l},listOfSpecies{k})
                                obj(ll).chromosome(l) = false;
                                obj(ll).fixed(l) = false;
                            end
                        end
                    end
                elseif isa(listOfSpecies,'char')
                    for l = 1:length(obj(ll).names),
                        if strcmp(obj(ll).names{l},listOfSpecies)
                            obj(ll).chromosome(l) = false;
                            obj(ll).fixed(l) = false;
                        end
                    end
                else
                    %
                end
                obj(ll).index = find(obj(ll).chromosome);
                obj(ll).speciesNotInclude = find(~obj(ll).chromosome);
            end
        end
        
        function obj = fix(obj,listOfSpecies)
            % sets species to non-selectable for removing
            if isa(listOfSpecies,'numeric')
                for l = 1:length(obj)
                    for k = 1:length(listOfSpecies)  
                        obj(l).fixed(listOfSpecies(k)) = true;                   
                    end
                end
            elseif isa(listOfSpecies,'cell')
                for ll = 1:length(obj)
                    for l = 1:length(obj(ll).names),                    
                        for k = 1:length(listOfSpecies)                         
                            if strcmp(obj(ll).names{l},listOfSpecies{k})                             
                                obj(ll).fixed(l) = true;
                            end
                        end
                    end
                end
            elseif isa(listOfSpecies,'char')
                for ll = 1:length(obj)
                    for l = 1:length(obj(ll).names),                    
                        if strcmp(obj.names{l},listOfSpecies)                        
                            obj.fixed(l) = true;
                        end
                    end
                end                
            else
                %
            end
        end
        
        function obj = unfix(obj,listOfSpecies)
            for ll = 1:length(obj)
                if isa(listOfSpecies,'numeric')
                    for k = 1:length(listOfSpecies)  
                        obj(ll).fixed(listOfSpecies(k)) = false;                   
                    end
                elseif isa(listOfSpecies,'cell')
                    for l = 1:length(obj(ll).names),
                        for k = 1:length(listOfSpecies)                         
                            if strcmp(obj(ll).names{l},listOfSpecies{k})                             
                                obj(ll).fixed(l) = false;
                            end
                        end
                    end
                elseif isa(listOfSpecies,'char')
                    for l = 1:length(obj(ll).names),
                        if strcmp(obj(ll).names{l},listOfSpecies)                        
                            obj(ll).fixed(l) = false;
                        end
                    end
                else
                    %
                end
            end
        end        
        
        function obj = mutation(obj,prob)
           if nargin <2
               prob = 0.3;
           end
           for ll = 1:length(obj)
               obj(ll).chromosome(~obj(ll).fixed) = mut(obj(ll).chromosome(~obj(ll).fixed),prob);
               obj(ll).index = find(obj(ll).chromosome); 
               obj(ll).speciesNotInclude = find(~obj(ll).chromosome);           
               obj(ll).value = inf;
           end
        end
        
        function obj = mutationN(obj,N)
            for ll = 1:length(obj)
                %obj = obj.mutationN(N)
                % mutates only N entries in obj.chromosome and only if
                % it is not fixed
                indx = 1:length(obj(ll).chromosome);
                for k = 1:N                
                    i = randi(length(indx));
                    if ~obj(ll).fixed(indx(i))
                        obj(ll).chromosome(indx(i)) = ~obj(ll).chromosome(indx(i));
                        indx(i) = [];
                    end
                end
                obj(ll).index = find(obj(ll).chromosome);
                obj(ll).speciesNotInclude = find(~obj(ll).chromosome); 
                obj(ll).value = inf;  
            end
        end
        
        function obj = mutationPlus(obj,N)
            %obj = mutationPlus(obj,N) 
            % Adds randomly N species to the mechanism
            % It loops over all members of obj ...
            for ll = 1:length(obj)
                if isempty(N)
                    N = fix(length(obj(ll).index)/10+1); % approx 10% will be added
                end
                %obj = obj.mutationN(N)
                % mutates only N entries in obj.chromosome and only if
                % it is not fixed
                indx = 1:length(obj(ll).chromosome);
                for k = 1:N                
                    i = randi(length(indx));
                    if ~obj(ll).fixed(indx(i))
                        obj(ll).chromosome(indx(i)) = true;
                        indx(i) = [];
                    end
                end
                obj(ll).index = find(obj(ll).chromosome);
                obj(ll).speciesNotInclude = find(~obj(ll).chromosome); 
                obj(ll).value = inf;  
            end
        end
        
        function obj = mutationMinus(obj,N)
            %obj = mutationMinus(obj,N)
            % Removes randomly N species from the mechanism            
            % It loops over all members  of obj ...
            for ll = 1:length(obj)
                if isempty(N)
                    N = fix(length(obj(ll).index)/10+1); % approx 10% will be added
                end
                %obj = obj.mutationN(N)
                % mutates only N entries in obj.chromosome and only if
                % it is not fixed
                indx = 1:length(obj(ll).chromosome);
                for k = 1:N                
                    i = randi(length(indx));
                    if ~obj(ll).fixed(indx(i))
                        obj(ll).chromosome(indx(i)) = false;
                        indx(i) = [];
                    end
                end
                obj(ll).index = find(obj(ll).chromosome);
                obj(ll).speciesNotInclude = find(~obj(ll).chromosome); 
                obj(ll).value = inf;  
            end
        end
        
        
        function obj = mutationFixedN(obj,N,rounds)
            indx = find(obj.fixed); % indices of fixed species
            free = 1:length(obj.chromosome);
            free(indx) = []; %#ok<FNDSB> % clear the fixed from the mutation list
            nOfSpecies = sum(obj.chromosome); % how many species 
            % are in the mechanism
            nFree = length(free); % how many species can be mutated
            if sum(obj.fixed)>N
                error('mutationWithFixedSpeciesNumber:WrongNumberOfSpecies',...
                    'The number of species in a mechnism must be larger than the number of fixed species')
            end
            if nOfSpecies>N
                % too many species in the mechanism, only deleting
                % allowed.             
                while nOfSpecies>N                
                    cur = randi(nFree) ;
                    obj.chromosome(free(cur)) = false;
                    nOfSpecies = sum(obj.chromosome);
                    obj.index = find(obj.chromosome); 
                    obj.speciesNotInclude = find(~obj.chromosome);
                    obj.value = inf;
                end
            else
                for l = 1:rounds
                    cur = randi(nFree); % a candidate to mutate               
                    if ~obj.chromosome(free(cur))&&(N>nOfSpecies)
                        obj.chromosome(free(cur)) = true;
                        nOfSpecies = sum(obj.chromosome);
                    else
                        obj.chromosome(free(cur)) = false;
                        nOfSpecies = sum(obj.chromosome);
                        %                     fprintf('1=>0\n')    ;            
                    end
                    obj.index = find(obj.chromosome);
                    obj.speciesNotInclude = find(~obj.chromosome);
                    obj.value = inf;                   
                end
            end
            
        end

        function [obj1,obj2] = xing(obj1,obj2)
            %crossing of two individuals
            
            if ~strcmp(obj1.mechanism,obj2.mechanism)
                error('xing:BaseMechError','Both individuals must base on the same mechanism.')
            end
            if length(obj1)>1||length(obj2)>1
                error('individual:xing:OnlyScalarInput','The arguments must be single individual objects.')
            end
            pos1 = randi(length(obj1.chromosome));
            pos2 = randi(length(obj1.chromosome)); 
%             pos2 =  length(obj1.chromosome);
            part1.c = obj1.chromosome(min(pos1,pos2):max(pos1,pos2));
            part1.f = obj1.fixed(min(pos1,pos2):max(pos1,pos2));
            obj1.chromosome(min(pos1,pos2):max(pos1,pos2)) = obj2.chromosome(min(pos1,pos2):max(pos1,pos2));
            obj1.fixed(min(pos1,pos2):max(pos1,pos2)) = obj2.fixed(min(pos1,pos2):max(pos1,pos2));
            obj1.index = find(obj1.chromosome); 
            obj1.speciesNotInclude = find(~obj1.chromosome);
            obj2.chromosome(min(pos1,pos2):max(pos1,pos2)) =  part1.c;
            obj2.fixed(min(pos1,pos2):max(pos1,pos2)) =  part1.f;
            obj2.index = find(obj2.chromosome); 
            obj2.speciesNotInclude = find(~obj2.chromosome);            
            obj1.value = inf;            
            obj2.value = inf;
        end
        
        % methods to manipulate the "reaction chromosome"
        function obj = mutationR(obj,prob)
            % mutates the reaction cromosom
            if nargin <2
                prob = 0.3;
            end
            for ll = 1:length(obj)
                obj(ll).reactions = mut(obj(ll).reactions,prob); 
                obj(ll).value = inf;
            end            
        end
        
        function [obj1,obj2] = xingR(obj1,obj2)
            % x-ing of the reactions cromosom
            
            if length(obj1)>1||length(obj2)>1
                error('individual:xing:OnlyScalarInput','The arguments must be single individual objects.')
            end
            pos1 = randi(length(obj1.reactions));
            pos2 = randi(length(obj1.reactions)); 
            excange = obj1.chromosome(min(pos1,pos2):max(pos1,pos2));
            obj1.reactions(min(pos1,pos2):max(pos1,pos2)) = obj2.reactions(min(pos1,pos2):max(pos1,pos2));
            obj2.reactions(min(pos1,pos2):max(pos1,pos2)) =  excange;
        end
        
        
    end
    
end

function individualsListOut = selection(~,individualsListIn,varargin)
%individualsListOut = selection(individualsListIn,[argument,value]) 
% selection takes care that no identical indviduals  appear in the output
% list 
switch length(varargin)
    case 0
        numberOfSurvivors = min(4,length(individualsListIn));
        cases = 2;
    case 2
        if ~isnumeric(varargin{2})
            error('selection:ArgumentMustBeNumeric','The second argument must be a scalar')
        else
            if strcmp(varargin{1},'threshold') 
                cases = 1;
            elseif strcmp(varargin{1},'survivors')
                cases = 2;
                numberOfSurvivors = min(length(individualsListIn),varargin{2});
                if length(individualsListIn)<varargin{2}
                    error('selection:ArgumentFitting',...
                        'The number of survivors is larger than the number of members in the population.')
                end
            else               
                error('selection:ArgumentIsNotValid',...
                    'The argument is not defined: It must be eigther threshold or survivors')
            end
        end        
    otherwise
        %
        error('selection:WrongNumberOfArguments','There are more than two or only one argument.')
end
        
n = length(individualsListIn);
switch cases
    case 1 % all individuals survive iff their value of fitness is <= threshold 
        m = 0;
        for k = 1:n           
            if individualsListIn(k).value<=varargin{2}
                unique = true;
                mm = m;
                for l = 1:mm                     
                    if individualsListIn(k).chromosome==individualsListOut(l).chromosome
                        unique = false; 
                        break
                    end
                end
                if unique
                   m = m+1;
                   individualsListOut(m) = individualsListIn(k);
                end
            end
        end                
    case 2 % we select the numberOfSurvivors-th fittest
        values = zeros(1,n);
        for k = 1:n     % copy the .value in a  vector
            values(k) = individualsListIn(k).value;
        end
        [~,indx] = sort(values);
        m = 0;
        for k = 1:n            
            unique = true;
            mm = m;
            for l = 1:mm
                if individualsListIn(indx(k)).chromosome==individualsListOut(l).chromosome
                    unique = false; 
                    break
                end
            end
            if unique
                m = m+1;
                individualsListOut(m) = individualsListIn(indx(k));
            end
            if m>=numberOfSurvivors 
                break
            end
        end   
    otherwise
        error('individual:selction:StrangeError',...
            'Ooops, strange things happen here ... you NEVER-EVER  should see this message!')
end
end
